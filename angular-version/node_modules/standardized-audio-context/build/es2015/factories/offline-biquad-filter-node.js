import { OfflineAudioNodeProxy } from '../offline-audio-node';
export class OfflineBiquadFilterNodeFakerProxy extends OfflineAudioNodeProxy {
    constructor({ fakeNodeStore, nativeNode, offlineAudioContext }) {
        super({
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore,
            numberOfInputs: 1,
            numberOfOutputs: 1,
            offlineAudioContext
        });
        this._nativeNode = nativeNode;
        this._type = nativeNode.type;
    }
    get detune() {
        // @todo Fake a proper AudioParam.
        const audioParam = {
            cancelScheduledValues: (startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            defaultValue: 0,
            exponentialRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            linearRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setTargetAtTime: (target, startTime, timeConstant) => {
                startTime; // tslint:disable-line:no-unused-expression
                target; // tslint:disable-line:no-unused-expression
                timeConstant; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueAtTime: (value, startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueCurveAtTime: (values, startTime, duration) => {
                duration; // tslint:disable-line:no-unused-expression
                startTime; // tslint:disable-line:no-unused-expression
                values; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            value: 0
        };
        return audioParam;
    }
    get frequency() {
        // @todo Fake a proper AudioParam.
        const audioParam = {
            cancelScheduledValues: (startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            defaultValue: 350,
            exponentialRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            linearRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setTargetAtTime: (target, startTime, timeConstant) => {
                startTime; // tslint:disable-line:no-unused-expression
                target; // tslint:disable-line:no-unused-expression
                timeConstant; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueAtTime: (value, startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueCurveAtTime: (values, startTime, duration) => {
                duration; // tslint:disable-line:no-unused-expression
                startTime; // tslint:disable-line:no-unused-expression
                values; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            value: 350
        };
        return audioParam;
    }
    get gain() {
        // @todo Fake a proper AudioParam.
        const audioParam = {
            cancelScheduledValues: (startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            defaultValue: 0,
            exponentialRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            linearRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setTargetAtTime: (target, startTime, timeConstant) => {
                startTime; // tslint:disable-line:no-unused-expression
                target; // tslint:disable-line:no-unused-expression
                timeConstant; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueAtTime: (value, startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueCurveAtTime: (values, startTime, duration) => {
                duration; // tslint:disable-line:no-unused-expression
                startTime; // tslint:disable-line:no-unused-expression
                values; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            value: 0
        };
        return audioParam;
    }
    get Q() {
        // @todo Fake a proper AudioParam.
        const audioParam = {
            cancelScheduledValues: (startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            defaultValue: 1,
            exponentialRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            linearRampToValueAtTime: (value, endTime) => {
                endTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setTargetAtTime: (target, startTime, timeConstant) => {
                startTime; // tslint:disable-line:no-unused-expression
                target; // tslint:disable-line:no-unused-expression
                timeConstant; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueAtTime: (value, startTime) => {
                startTime; // tslint:disable-line:no-unused-expression
                value; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            setValueCurveAtTime: (values, startTime, duration) => {
                duration; // tslint:disable-line:no-unused-expression
                startTime; // tslint:disable-line:no-unused-expression
                values; // tslint:disable-line:no-unused-expression
                return audioParam;
            },
            value: 1
        };
        return audioParam;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
    }
    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        return this._nativeNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
    }
}
export class OfflineBiquadFilterNodeFaker {
    constructor({ fakeNodeStore, nativeNode, offlineAudioContext }) {
        this._node = null;
        this._proxy = new OfflineBiquadFilterNodeFakerProxy({ fakeNodeStore, nativeNode, offlineAudioContext });
        this._sources = new Map();
        fakeNodeStore.set(this._proxy, this);
    }
    get proxy() {
        return this._proxy;
    }
    render(offlineAudioContext) {
        if (this._node !== null) {
            return Promise.resolve(this._node);
        }
        this._node = offlineAudioContext.createBiquadFilter();
        this._node.type = this._proxy.type;
        const promises = Array
            .from(this._sources)
            .map(([source, { input, output }]) => {
            // For some reason this currently needs to be a function body with a return statement. The shortcut syntax causes an error.
            return source
                .render(offlineAudioContext)
                .then((node) => node.connect(this._node, output, input));
        });
        return Promise
            .all(promises)
            .then(() => this._node);
    }
    wire(source, output, input) {
        this._sources.set(source, { input, output });
        return this._proxy;
    }
    unwire(source) {
        this._sources.delete(source);
    }
}
export class OfflineBiquadFilterNodeFakerFactory {
    create({ fakeNodeStore, nativeNode, offlineAudioContext }) {
        return new OfflineBiquadFilterNodeFaker({
            fakeNodeStore,
            nativeNode, offlineAudioContext
        });
    }
}
//# sourceMappingURL=/users/chrisguttandin/repositories/standardized-audio-context/node_modules/tsconfig-holy-grail/src/factories/offline-biquad-filter-node.js.map