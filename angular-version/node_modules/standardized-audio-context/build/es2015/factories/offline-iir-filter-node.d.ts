import { IAudioNode, IIIRFilterNode, IOfflineAudioContext, IOfflineAudioNodeFaker, IUnpatchedOfflineAudioContextConstructor } from '../interfaces';
import { OfflineAudioNodeProxy } from '../offline-audio-node';
import { PromiseSupportTester } from '../testers/promise-support';
import { TUnpatchedOfflineAudioContext } from '../types';
import { InvalidStateErrorFactory } from './invalid-state-error';
import { NotSupportedErrorFactory } from './not-supported-error';
export interface IOfflineIIRFilterNodeProxyOptions {
    fakeNodeStore: WeakMap<IAudioNode, IOfflineAudioNodeFaker>;
    feedback: number[];
    feedforward: number[];
    nativeNode: null | IIIRFilterNode;
    notSupportedErrorFactory: NotSupportedErrorFactory;
    offlineAudioContext: IOfflineAudioContext;
    sampleRate: number;
}
export declare class OfflineIIRFilterNodeProxy extends OfflineAudioNodeProxy implements IIIRFilterNode {
    private _feedback;
    private _feedforward;
    private _nativeNode;
    private _notSupportedErrorFactory;
    private _nyquist;
    constructor({fakeNodeStore, feedback, feedforward, nativeNode, notSupportedErrorFactory, offlineAudioContext, sampleRate}: IOfflineIIRFilterNodeProxyOptions);
    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
}
export interface IOfflineIIRFilterNodeFakerOptions {
    fakeNodeStore: WeakMap<IAudioNode, IOfflineAudioNodeFaker>;
    feedback: number[];
    feedforward: number[];
    invalidStateErrorFactory: InvalidStateErrorFactory;
    length: number;
    nativeNode: null | IIIRFilterNode;
    notSupportedErrorFactory: NotSupportedErrorFactory;
    numberOfChannels: number;
    offlineAudioContext: IOfflineAudioContext;
    promiseSupportTester: PromiseSupportTester;
    sampleRate: number;
    unpatchedOfflineAudioContextConstructor: IUnpatchedOfflineAudioContextConstructor;
}
export declare class OfflineIIRFilterNodeFaker implements IOfflineAudioNodeFaker {
    private _feedback;
    private _feedforward;
    private _invalidStateErrorFactory;
    private _length;
    private _nativeNode;
    private _node;
    private _notSupportedErrorFactory;
    private _numberOfChannels;
    private _promiseSupportTester;
    private _proxy;
    private _sources;
    private _unpatchedOfflineAudioContextConstructor;
    constructor({fakeNodeStore, feedback, feedforward, invalidStateErrorFactory, length, nativeNode, notSupportedErrorFactory, numberOfChannels, offlineAudioContext, promiseSupportTester, sampleRate, unpatchedOfflineAudioContextConstructor}: IOfflineIIRFilterNodeFakerOptions);
    readonly proxy: OfflineIIRFilterNodeProxy;
    private _applyFilter(renderedBuffer, offlineAudioContext);
    render(offlineAudioContext: TUnpatchedOfflineAudioContext): Promise<AudioNode>;
    wire(source: IOfflineAudioNodeFaker, output: number, input: number): OfflineIIRFilterNodeProxy;
    unwire(source: IOfflineAudioNodeFaker): void;
}
export interface IOfflineIIRFilterNodeFakerFactoryOptions {
    fakeNodeStore: WeakMap<IAudioNode, IOfflineAudioNodeFaker>;
    feedback: number[];
    feedforward: number[];
    length: number;
    nativeNode: null | IIIRFilterNode;
    numberOfChannels: number;
    offlineAudioContext: IOfflineAudioContext;
    sampleRate: number;
}
export declare class OfflineIIRFilterNodeFakerFactory {
    private _unpatchedOfflineAudioContextConstructor;
    private _invalidStateErrorFactory;
    private _notSupportedErrorFactory;
    private _promiseSupportTester;
    constructor(_unpatchedOfflineAudioContextConstructor: IUnpatchedOfflineAudioContextConstructor, _invalidStateErrorFactory: InvalidStateErrorFactory, _notSupportedErrorFactory: NotSupportedErrorFactory, _promiseSupportTester: PromiseSupportTester);
    create({fakeNodeStore, feedback, feedforward, length, nativeNode, numberOfChannels, offlineAudioContext, sampleRate}: IOfflineIIRFilterNodeFakerFactoryOptions): OfflineIIRFilterNodeFaker;
}
