var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Injectable } from '@angular/core';
import { InvalidAccessErrorFactory } from '../factories/invalid-access-error';
import { InvalidStateErrorFactory } from '../factories/invalid-state-error';
import { NotSupportedErrorFactory } from '../factories/not-supported-error';
function divide(a, b) {
    var denominator = (b[0] * b[0]) + (b[1] * b[1]);
    return [(((a[0] * b[0]) + (a[1] * b[1])) / denominator), (((a[1] * b[0]) - (a[0] * b[1])) / denominator)];
}
function multiply(a, b) {
    return [((a[0] * b[0]) - (a[1] * b[1])), ((a[0] * b[1]) + (a[1] * b[0]))];
}
function evaluatePolynomial(coefficient, z) {
    var result = [0, 0];
    for (var i = coefficient.length - 1; i >= 0; i -= 1) {
        result = multiply(result, z);
        result[0] += coefficient[i];
    }
    return result;
}
var IIRFilterNodeFaker = (function () {
    function IIRFilterNodeFaker(_invalidAccessErrorFactory, _invalidStateErrorFactory, _notSupportedErrorFactory) {
        this._invalidAccessErrorFactory = _invalidAccessErrorFactory;
        this._invalidStateErrorFactory = _invalidStateErrorFactory;
        this._notSupportedErrorFactory = _notSupportedErrorFactory;
    }
    IIRFilterNodeFaker.prototype.fake = function (feedforward, feedback, audioContext, unpatchedAudioContext) {
        var _this = this;
        var bufferIndex = 0;
        var bufferLength = 32;
        var feedbackLength = feedback.length;
        var feedforwardLength = feedforward.length;
        if (feedforward.length === 0 || feedforward.length > 20 || feedback.length === 0 || feedback.length > 20) {
            throw this._notSupportedErrorFactory.create();
        }
        if (feedforward[0] === 0 || feedback[0] === 0) {
            throw this._invalidStateErrorFactory.create();
        }
        if (feedback[0] !== 1) {
            for (var i = 0; i < feedforwardLength; i += 1) {
                feedforward[i] /= feedback[0];
            }
            for (var i = 1; i < feedbackLength; i += 1) {
                feedback[i] /= feedback[0];
            }
        }
        var gainNode = audioContext.createGain();
        var nyquist = audioContext.sampleRate / 2;
        // @todo Remove this once the audioContext supports the createScriptProcessor() method, too.
        var scriptProcessorNode = unpatchedAudioContext.createScriptProcessor(256, gainNode.channelCount, gainNode.channelCount);
        var bufferSize = scriptProcessorNode.bufferSize;
        var xBuffer = new Float32Array(bufferLength);
        var yBuffer = new Float32Array(bufferLength);
        var minLength = Math.min(feedbackLength, feedforwardLength);
        // @todo Use TypedArray.prototype.fill() once it lands in Safari.
        for (var i = 0; i < bufferLength; i += 1) {
            xBuffer[i] = 0;
            yBuffer[i] = 0;
        }
        // This implementation as shamelessly inspired by source code of
        // tslint:disable-next-line:max-line-length
        // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
        scriptProcessorNode.onaudioprocess = function (event) {
            var inputBuffer = event.inputBuffer;
            var outputBuffer = event.outputBuffer;
            var numberOfChannels = inputBuffer.numberOfChannels;
            for (var i = 0; i < numberOfChannels; i += 1) {
                var input = inputBuffer.getChannelData(i);
                var output = outputBuffer.getChannelData(i);
                for (var j = 0; j < bufferSize; j += 1) {
                    var y = feedforward[0] * input[j];
                    for (var k = 1; k < minLength; k += 1) {
                        var x = (bufferIndex - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise
                        y += feedforward[k] * xBuffer[x];
                        y -= feedback[k] * yBuffer[x];
                    }
                    for (var k = minLength; k < feedforwardLength; k += 1) {
                        y += feedforward[k] * xBuffer[(bufferIndex - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise
                    }
                    for (var k = minLength; k < feedbackLength; k += 1) {
                        y -= feedback[k] * yBuffer[(bufferIndex - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise
                    }
                    xBuffer[bufferIndex] = input[j];
                    yBuffer[bufferIndex] = y;
                    bufferIndex = (bufferIndex + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise
                    output[j] = y;
                }
            }
        };
        gainNode.getFrequencyResponse = function (frequencyHz, magResponse, phaseResponse) {
            if (magResponse.length === 0 || phaseResponse.length === 0) {
                throw _this._notSupportedErrorFactory.create();
            }
            var length = frequencyHz.length;
            for (var i = 0; i < length; i += 1) {
                var omega = -Math.PI * (frequencyHz[i] / nyquist);
                var z = [Math.cos(omega), Math.sin(omega)];
                var numerator = evaluatePolynomial(feedforward, z);
                var denominator = evaluatePolynomial(feedback, z);
                var response = divide(numerator, denominator);
                magResponse[i] = Math.sqrt((response[0] * response[0]) + (response[1] * response[1]));
                phaseResponse[i] = Math.atan2(response[1], response[0]);
            }
        };
        gainNode.connect(scriptProcessorNode);
        gainNode.connect = function (destination, output, input) {
            if (output === void 0) { output = 0; }
            if (input === void 0) { input = 0; }
            try {
                scriptProcessorNode.connect.call(scriptProcessorNode, destination, output, input);
            }
            catch (err) {
                if (err.code === 12) {
                    throw _this._invalidAccessErrorFactory.create();
                }
                throw err;
            }
            return destination;
        };
        return gainNode;
    };
    return IIRFilterNodeFaker;
}());
IIRFilterNodeFaker = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [InvalidAccessErrorFactory,
        InvalidStateErrorFactory,
        NotSupportedErrorFactory])
], IIRFilterNodeFaker);
export { IIRFilterNodeFaker };
//# sourceMappingURL=/users/chrisguttandin/repositories/standardized-audio-context/node_modules/tsconfig-holy-grail/src/fakers/iir-filter-node.js.map