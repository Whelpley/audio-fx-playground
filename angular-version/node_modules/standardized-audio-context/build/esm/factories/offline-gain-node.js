var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { OfflineAudioNodeProxy } from '../offline-audio-node';
var OfflineGainNodeFakerProxy = (function (_super) {
    __extends(OfflineGainNodeFakerProxy, _super);
    function OfflineGainNodeFakerProxy(_a) {
        var fakeNodeStore = _a.fakeNodeStore, offlineAudioContext = _a.offlineAudioContext;
        return _super.call(this, {
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore: fakeNodeStore,
            numberOfInputs: 1,
            numberOfOutputs: 1,
            offlineAudioContext: offlineAudioContext
        }) || this;
    }
    Object.defineProperty(OfflineGainNodeFakerProxy.prototype, "gain", {
        get: function () {
            // @todo Fake a proper AudioParam.
            var audioParam = {
                cancelScheduledValues: function (startTime) {
                    startTime; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                defaultValue: 1,
                exponentialRampToValueAtTime: function (value, endTime) {
                    endTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                linearRampToValueAtTime: function (value, endTime) {
                    endTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setTargetAtTime: function (target, startTime, timeConstant) {
                    startTime; // tslint:disable-line:no-unused-expression
                    target; // tslint:disable-line:no-unused-expression
                    timeConstant; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setValueAtTime: function (value, startTime) {
                    startTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setValueCurveAtTime: function (values, startTime, duration) {
                    duration; // tslint:disable-line:no-unused-expression
                    startTime; // tslint:disable-line:no-unused-expression
                    values; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                value: 1
            };
            return audioParam;
        },
        enumerable: true,
        configurable: true
    });
    return OfflineGainNodeFakerProxy;
}(OfflineAudioNodeProxy));
export { OfflineGainNodeFakerProxy };
var OfflineGainNodeFaker = (function () {
    function OfflineGainNodeFaker(_a) {
        var fakeNodeStore = _a.fakeNodeStore, offlineAudioContext = _a.offlineAudioContext;
        this._node = null;
        this._proxy = new OfflineGainNodeFakerProxy({ fakeNodeStore: fakeNodeStore, offlineAudioContext: offlineAudioContext });
        this._sources = new Map();
        fakeNodeStore.set(this._proxy, this);
    }
    Object.defineProperty(OfflineGainNodeFaker.prototype, "proxy", {
        get: function () {
            return this._proxy;
        },
        enumerable: true,
        configurable: true
    });
    OfflineGainNodeFaker.prototype.render = function (offlineAudioContext) {
        var _this = this;
        if (this._node !== null) {
            return Promise.resolve(this._node);
        }
        this._node = offlineAudioContext.createGain();
        var promises = Array
            .from(this._sources)
            .map(function (_a) {
            var source = _a[0], _b = _a[1], input = _b.input, output = _b.output;
            // For some reason this currently needs to be a function body with a return statement. The shortcut syntax causes an error.
            return source
                .render(offlineAudioContext)
                .then(function (node) { return node.connect(_this._node, output, input); });
        });
        return Promise
            .all(promises)
            .then(function () { return _this._node; });
    };
    OfflineGainNodeFaker.prototype.wire = function (source, output, input) {
        this._sources.set(source, { input: input, output: output });
        return this._proxy;
    };
    OfflineGainNodeFaker.prototype.unwire = function (source) {
        this._sources.delete(source);
    };
    return OfflineGainNodeFaker;
}());
export { OfflineGainNodeFaker };
var OfflineGainNodeFakerFactory = (function () {
    function OfflineGainNodeFakerFactory() {
    }
    OfflineGainNodeFakerFactory.prototype.create = function (_a) {
        var fakeNodeStore = _a.fakeNodeStore, offlineAudioContext = _a.offlineAudioContext;
        return new OfflineGainNodeFaker({ fakeNodeStore: fakeNodeStore, offlineAudioContext: offlineAudioContext });
    };
    return OfflineGainNodeFakerFactory;
}());
export { OfflineGainNodeFakerFactory };
//# sourceMappingURL=/users/chrisguttandin/repositories/standardized-audio-context/node_modules/tsconfig-holy-grail/src/factories/offline-gain-node.js.map