var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Inject, Injectable } from '@angular/core';
import { OfflineAudioNodeProxy } from '../offline-audio-node';
import { unpatchedOfflineAudioContextConstructor } from '../providers/unpatched-offline-audio-context-constructor';
import { PromiseSupportTester } from '../testers/promise-support';
import { InvalidStateErrorFactory } from './invalid-state-error';
import { NotSupportedErrorFactory } from './not-supported-error';
function divide(a, b) {
    var denominator = (b[0] * b[0]) + (b[1] * b[1]);
    return [(((a[0] * b[0]) + (a[1] * b[1])) / denominator), (((a[1] * b[0]) - (a[0] * b[1])) / denominator)];
}
function multiply(a, b) {
    return [((a[0] * b[0]) - (a[1] * b[1])), ((a[0] * b[1]) + (a[1] * b[0]))];
}
function evaluatePolynomial(coefficient, z) {
    var result = [0, 0];
    for (var i = coefficient.length - 1; i >= 0; i -= 1) {
        result = multiply(result, z);
        result[0] += coefficient[i];
    }
    return result;
}
var OfflineIIRFilterNodeProxy = (function (_super) {
    __extends(OfflineIIRFilterNodeProxy, _super);
    function OfflineIIRFilterNodeProxy(_a) {
        var fakeNodeStore = _a.fakeNodeStore, feedback = _a.feedback, feedforward = _a.feedforward, nativeNode = _a.nativeNode, notSupportedErrorFactory = _a.notSupportedErrorFactory, offlineAudioContext = _a.offlineAudioContext, sampleRate = _a.sampleRate;
        var _this = _super.call(this, {
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore: fakeNodeStore,
            numberOfInputs: 1,
            numberOfOutputs: 1,
            offlineAudioContext: offlineAudioContext
        }) || this;
        _this._feedback = feedback;
        _this._feedforward = feedforward;
        _this._nativeNode = nativeNode;
        _this._notSupportedErrorFactory = notSupportedErrorFactory;
        _this._nyquist = sampleRate / 2;
        return _this;
    }
    OfflineIIRFilterNodeProxy.prototype.getFrequencyResponse = function (frequencyHz, magResponse, phaseResponse) {
        // Bug #9: Safari does not support IIRFilterNodes.
        if (this._nativeNode !== null) {
            return this._nativeNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
        }
        if (magResponse.length === 0 || phaseResponse.length === 0) {
            throw this._notSupportedErrorFactory.create();
        }
        var length = frequencyHz.length;
        for (var i = 0; i < length; i += 1) {
            var omega = -Math.PI * (frequencyHz[i] / this._nyquist);
            var z = [Math.cos(omega), Math.sin(omega)];
            var numerator = evaluatePolynomial(this._feedforward, z);
            var denominator = evaluatePolynomial(this._feedback, z);
            var response = divide(numerator, denominator);
            magResponse[i] = Math.sqrt((response[0] * response[0]) + (response[1] * response[1]));
            phaseResponse[i] = Math.atan2(response[1], response[0]);
        }
    };
    return OfflineIIRFilterNodeProxy;
}(OfflineAudioNodeProxy));
export { OfflineIIRFilterNodeProxy };
var OfflineIIRFilterNodeFaker = (function () {
    function OfflineIIRFilterNodeFaker(_a) {
        var fakeNodeStore = _a.fakeNodeStore, feedback = _a.feedback, feedforward = _a.feedforward, invalidStateErrorFactory = _a.invalidStateErrorFactory, length = _a.length, nativeNode = _a.nativeNode, notSupportedErrorFactory = _a.notSupportedErrorFactory, numberOfChannels = _a.numberOfChannels, offlineAudioContext = _a.offlineAudioContext, promiseSupportTester = _a.promiseSupportTester, sampleRate = _a.sampleRate, unpatchedOfflineAudioContextConstructor = _a.unpatchedOfflineAudioContextConstructor;
        if (feedback.length === 0 || feedback.length > 20) {
            throw notSupportedErrorFactory.create();
        }
        if (feedback[0] === 0) {
            throw invalidStateErrorFactory.create();
        }
        if (feedforward.length === 0 || feedforward.length > 20) {
            throw notSupportedErrorFactory.create();
        }
        if (feedforward[0] === 0) {
            throw invalidStateErrorFactory.create();
        }
        this._feedback = feedback;
        this._feedforward = feedforward;
        this._invalidStateErrorFactory = invalidStateErrorFactory;
        this._length = length;
        this._nativeNode = nativeNode;
        this._node = null;
        this._notSupportedErrorFactory = notSupportedErrorFactory;
        this._numberOfChannels = numberOfChannels;
        this._promiseSupportTester = promiseSupportTester;
        this._proxy = new OfflineIIRFilterNodeProxy({
            fakeNodeStore: fakeNodeStore,
            feedback: feedback,
            feedforward: feedforward,
            nativeNode: nativeNode,
            notSupportedErrorFactory: notSupportedErrorFactory,
            offlineAudioContext: offlineAudioContext,
            sampleRate: sampleRate
        });
        this._sources = new Map();
        this._unpatchedOfflineAudioContextConstructor = unpatchedOfflineAudioContextConstructor;
        fakeNodeStore.set(this._proxy, this);
    }
    Object.defineProperty(OfflineIIRFilterNodeFaker.prototype, "proxy", {
        get: function () {
            return this._proxy;
        },
        enumerable: true,
        configurable: true
    });
    OfflineIIRFilterNodeFaker.prototype._applyFilter = function (renderedBuffer, offlineAudioContext) {
        var bufferIndex = 0;
        var bufferLength = 32;
        var feedback = this._feedback;
        var feedbackLength = this._feedback.length;
        var feedforward = this._feedforward;
        var feedforwardLength = this._feedforward.length;
        if (feedforward.length === 0 || feedforward.length > 20 || feedback.length === 0 || feedback.length > 20) {
            throw this._notSupportedErrorFactory.create();
        }
        if (feedforward[0] === 0 || feedback[0] === 0) {
            throw this._invalidStateErrorFactory.create();
        }
        if (feedback[0] !== 1) {
            for (var i = 0; i < feedbackLength; i += 1) {
                feedforward[i] /= feedback[0];
            }
            for (var i = 1; i < feedforwardLength; i += 1) {
                feedback[i] /= feedback[0];
            }
        }
        var xBuffer = new Float32Array(bufferLength);
        var yBuffer = new Float32Array(bufferLength);
        var minLength = Math.min(feedbackLength, feedforwardLength);
        var filteredBuffer = offlineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
        // This implementation as shamelessly inspired by source code of
        // tslint:disable-next-line:max-line-length
        // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
        var numberOfChannels = renderedBuffer.numberOfChannels;
        for (var i = 0; i < numberOfChannels; i += 1) {
            var input = renderedBuffer.getChannelData(i);
            var output = filteredBuffer.getChannelData(i);
            // @todo Use TypedArray.prototype.fill() once it lands in Safari.
            for (var j = 0; j < bufferLength; j += 1) {
                xBuffer[j] = 0;
                yBuffer[j] = 0;
            }
            var inputLength = input.length;
            for (var j = 0; j < inputLength; j += 1) {
                var y = feedforward[0] * input[j];
                for (var k = 1; k < minLength; k += 1) {
                    var x = (bufferIndex - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise
                    y += feedforward[k] * xBuffer[x];
                    y -= feedback[k] * yBuffer[x];
                }
                for (var k = minLength; k < feedforwardLength; k += 1) {
                    y += feedforward[k] * xBuffer[(bufferIndex - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise
                }
                for (var k = minLength; k < feedbackLength; k += 1) {
                    y -= feedback[k] * yBuffer[(bufferIndex - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise
                }
                xBuffer[bufferIndex] = input[j];
                yBuffer[bufferIndex] = y;
                bufferIndex = (bufferIndex + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise
                output[j] = y;
            }
        }
        return filteredBuffer;
    };
    OfflineIIRFilterNodeFaker.prototype.render = function (offlineAudioContext) {
        var _this = this;
        if (this._node !== null) {
            return Promise.resolve(this._node);
        }
        // Bug #9: Safari does not support IIRFilterNodes.
        if (this._nativeNode) {
            this._node = offlineAudioContext.createIIRFilter(this._feedforward, this._feedback);
            var promises_1 = Array
                .from(this._sources)
                .map(function (_a) {
                var source = _a[0], _b = _a[1], input = _b.input, output = _b.output;
                /*
                 * For some reason this currently needs to be a function body with a return statement. The shortcut syntax causes an
                 * error.
                 */
                return source
                    .render(offlineAudioContext)
                    .then(function (node) { return node.connect(_this._node, output, input); });
            });
            return Promise
                .all(promises_1)
                .then(function () { return _this._node; });
        }
        // @todo Somehow retrieve the number of channels.
        var partialOfflineAudioContext = new this._unpatchedOfflineAudioContextConstructor(this._numberOfChannels, this._length, offlineAudioContext.sampleRate);
        var promises = Array
            .from(this._sources)
            .map(function (_a) {
            var source = _a[0], _b = _a[1], input = _b.input, output = _b.output;
            // For some reason this currently needs to be a function body with a return statement. The shortcut syntax causes an error.
            return source
                .render(partialOfflineAudioContext)
                .then(function (node) { return node.connect(partialOfflineAudioContext.destination, output, input); });
        });
        return Promise
            .all(promises)
            .then(function () {
            // Bug #21: Safari does not support promises yet.
            if (_this._promiseSupportTester.test(partialOfflineAudioContext)) {
                return partialOfflineAudioContext.startRendering();
            }
            return new Promise(function (resolve) {
                partialOfflineAudioContext.oncomplete = function (event) { return resolve(event.renderedBuffer); };
                partialOfflineAudioContext.startRendering();
            });
        })
            .then(function (renderedBuffer) {
            var audioBufferSourceNode = offlineAudioContext.createBufferSource();
            audioBufferSourceNode.buffer = _this._applyFilter(renderedBuffer, offlineAudioContext);
            audioBufferSourceNode.start(0);
            _this._node = audioBufferSourceNode;
            return _this._node;
        });
    };
    OfflineIIRFilterNodeFaker.prototype.wire = function (source, output, input) {
        this._sources.set(source, { input: input, output: output });
        return this._proxy;
    };
    OfflineIIRFilterNodeFaker.prototype.unwire = function (source) {
        this._sources.delete(source);
    };
    return OfflineIIRFilterNodeFaker;
}());
export { OfflineIIRFilterNodeFaker };
var OfflineIIRFilterNodeFakerFactory = (function () {
    function OfflineIIRFilterNodeFakerFactory(_unpatchedOfflineAudioContextConstructor, _invalidStateErrorFactory, _notSupportedErrorFactory, _promiseSupportTester) {
        this._unpatchedOfflineAudioContextConstructor = _unpatchedOfflineAudioContextConstructor;
        this._invalidStateErrorFactory = _invalidStateErrorFactory;
        this._notSupportedErrorFactory = _notSupportedErrorFactory;
        this._promiseSupportTester = _promiseSupportTester;
    }
    OfflineIIRFilterNodeFakerFactory.prototype.create = function (_a) {
        var fakeNodeStore = _a.fakeNodeStore, feedback = _a.feedback, feedforward = _a.feedforward, length = _a.length, nativeNode = _a.nativeNode, numberOfChannels = _a.numberOfChannels, offlineAudioContext = _a.offlineAudioContext, sampleRate = _a.sampleRate;
        return new OfflineIIRFilterNodeFaker({
            fakeNodeStore: fakeNodeStore,
            feedback: feedback,
            feedforward: feedforward,
            invalidStateErrorFactory: this._invalidStateErrorFactory,
            length: length,
            nativeNode: nativeNode,
            notSupportedErrorFactory: this._notSupportedErrorFactory,
            numberOfChannels: numberOfChannels,
            offlineAudioContext: offlineAudioContext,
            promiseSupportTester: this._promiseSupportTester,
            sampleRate: sampleRate,
            unpatchedOfflineAudioContextConstructor: this._unpatchedOfflineAudioContextConstructor
        });
    };
    return OfflineIIRFilterNodeFakerFactory;
}());
OfflineIIRFilterNodeFakerFactory = __decorate([
    Injectable(),
    __param(0, Inject(unpatchedOfflineAudioContextConstructor)),
    __metadata("design:paramtypes", [Object, InvalidStateErrorFactory,
        NotSupportedErrorFactory,
        PromiseSupportTester])
], OfflineIIRFilterNodeFakerFactory);
export { OfflineIIRFilterNodeFakerFactory };
//# sourceMappingURL=/users/chrisguttandin/repositories/standardized-audio-context/node_modules/tsconfig-holy-grail/src/factories/offline-iir-filter-node.js.map