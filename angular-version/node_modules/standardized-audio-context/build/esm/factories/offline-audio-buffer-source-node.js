var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { OfflineAudioNodeProxy } from '../offline-audio-node';
var OfflineAudioBufferSourceNodeFakerProxy = (function (_super) {
    __extends(OfflineAudioBufferSourceNodeFakerProxy, _super);
    function OfflineAudioBufferSourceNodeFakerProxy(_a) {
        var fakeNodeStore = _a.fakeNodeStore, offlineAudioContext = _a.offlineAudioContext;
        var _this = _super.call(this, {
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore: fakeNodeStore,
            numberOfInputs: 0,
            numberOfOutputs: 1,
            offlineAudioContext: offlineAudioContext
        }) || this;
        _this._buffer = null;
        _this._ownFakeNodeStore = fakeNodeStore;
        return _this;
    }
    Object.defineProperty(OfflineAudioBufferSourceNodeFakerProxy.prototype, "buffer", {
        get: function () {
            return this._buffer;
        },
        set: function (value) {
            // @todo Allow to set the buffer only onces.
            this._buffer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineAudioBufferSourceNodeFakerProxy.prototype, "onended", {
        get: function () {
            // @todo
            return null;
        },
        set: function (value) {
            // @todo
            value; // tslint:disable-line:no-unused-expression
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineAudioBufferSourceNodeFakerProxy.prototype, "detune", {
        get: function () {
            // @todo Fake a proper AudioParam.
            var audioParam = {
                cancelScheduledValues: function (startTime) {
                    startTime; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                defaultValue: 0,
                exponentialRampToValueAtTime: function (value, endTime) {
                    endTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                linearRampToValueAtTime: function (value, endTime) {
                    endTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setTargetAtTime: function (target, startTime, timeConstant) {
                    startTime; // tslint:disable-line:no-unused-expression
                    target; // tslint:disable-line:no-unused-expression
                    timeConstant; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setValueAtTime: function (value, startTime) {
                    startTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setValueCurveAtTime: function (values, startTime, duration) {
                    duration; // tslint:disable-line:no-unused-expression
                    startTime; // tslint:disable-line:no-unused-expression
                    values; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                value: 0
            };
            return audioParam;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineAudioBufferSourceNodeFakerProxy.prototype, "loop", {
        get: function () {
            // @todo
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineAudioBufferSourceNodeFakerProxy.prototype, "loopEnd", {
        get: function () {
            // @todo
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineAudioBufferSourceNodeFakerProxy.prototype, "loopStart", {
        get: function () {
            // @todo
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineAudioBufferSourceNodeFakerProxy.prototype, "playbackRate", {
        get: function () {
            // @todo Fake a proper AudioParam.
            var audioParam = {
                cancelScheduledValues: function (startTime) {
                    startTime; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                defaultValue: 1,
                exponentialRampToValueAtTime: function (value, endTime) {
                    endTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                linearRampToValueAtTime: function (value, endTime) {
                    endTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setTargetAtTime: function (target, startTime, timeConstant) {
                    startTime; // tslint:disable-line:no-unused-expression
                    target; // tslint:disable-line:no-unused-expression
                    timeConstant; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setValueAtTime: function (value, startTime) {
                    startTime; // tslint:disable-line:no-unused-expression
                    value; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                setValueCurveAtTime: function (values, startTime, duration) {
                    duration; // tslint:disable-line:no-unused-expression
                    startTime; // tslint:disable-line:no-unused-expression
                    values; // tslint:disable-line:no-unused-expression
                    return audioParam;
                },
                value: 1
            };
            return audioParam;
        },
        enumerable: true,
        configurable: true
    });
    OfflineAudioBufferSourceNodeFakerProxy.prototype.start = function (when, offset, duration) {
        if (when === void 0) { when = 0; }
        if (offset === void 0) { offset = 0; }
        var faker = this._ownFakeNodeStore.get(this);
        faker.start = { duration: duration, offset: offset, when: when };
    };
    OfflineAudioBufferSourceNodeFakerProxy.prototype.stop = function (when) {
        // @todo
        if (when === void 0) { when = 0; }
        when; // tslint:disable-line:no-unused-expression
    };
    return OfflineAudioBufferSourceNodeFakerProxy;
}(OfflineAudioNodeProxy));
export { OfflineAudioBufferSourceNodeFakerProxy };
var OfflineAudioBufferSourceNodeFaker = (function () {
    function OfflineAudioBufferSourceNodeFaker(_a) {
        var fakeNodeStore = _a.fakeNodeStore, offlineAudioContext = _a.offlineAudioContext;
        this._node = null;
        this._proxy = new OfflineAudioBufferSourceNodeFakerProxy({ fakeNodeStore: fakeNodeStore, offlineAudioContext: offlineAudioContext });
        this._sources = new Map();
        this._start = null;
        fakeNodeStore.set(this._proxy, this);
    }
    Object.defineProperty(OfflineAudioBufferSourceNodeFaker.prototype, "proxy", {
        get: function () {
            return this._proxy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineAudioBufferSourceNodeFaker.prototype, "start", {
        set: function (value) {
            this._start = value;
        },
        enumerable: true,
        configurable: true
    });
    OfflineAudioBufferSourceNodeFaker.prototype.render = function (offlineAudioContext) {
        var _this = this;
        if (this._node !== null) {
            return Promise.resolve(this._node);
        }
        this._node = offlineAudioContext.createBufferSource();
        this._node.buffer = this._proxy.buffer;
        if (this._start !== null) {
            var _a = this._start, duration = _a.duration, offset = _a.offset, when = _a.when;
            if (duration === undefined) {
                this._node.start(when, offset);
            }
            else {
                this._node.start(when, offset, duration);
            }
        }
        var promises = Array
            .from(this._sources)
            .map(function (_a) {
            var source = _a[0], _b = _a[1], input = _b.input, output = _b.output;
            // For some reason this currently needs to be a function body with a return statement. The shortcut syntax causes an error.
            return source
                .render(offlineAudioContext)
                .then(function (node) { return node.connect(_this._node, output, input); });
        });
        return Promise
            .all(promises)
            .then(function () { return _this._node; });
    };
    OfflineAudioBufferSourceNodeFaker.prototype.wire = function (source, output, input) {
        this._sources.set(source, { input: input, output: output });
        return this._proxy;
    };
    OfflineAudioBufferSourceNodeFaker.prototype.unwire = function (source) {
        this._sources.delete(source);
    };
    return OfflineAudioBufferSourceNodeFaker;
}());
export { OfflineAudioBufferSourceNodeFaker };
var OfflineAudioBufferSourceNodeFakerFactory = (function () {
    function OfflineAudioBufferSourceNodeFakerFactory() {
    }
    OfflineAudioBufferSourceNodeFakerFactory.prototype.create = function (_a) {
        var fakeNodeStore = _a.fakeNodeStore, offlineAudioContext = _a.offlineAudioContext;
        return new OfflineAudioBufferSourceNodeFaker({ fakeNodeStore: fakeNodeStore, offlineAudioContext: offlineAudioContext });
    };
    return OfflineAudioBufferSourceNodeFakerFactory;
}());
export { OfflineAudioBufferSourceNodeFakerFactory };
//# sourceMappingURL=/users/chrisguttandin/repositories/standardized-audio-context/node_modules/tsconfig-holy-grail/src/factories/offline-audio-buffer-source-node.js.map