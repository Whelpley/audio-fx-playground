import { OpaqueToken } from '@angular/core';
import { DataCloneErrorFactory } from '../factories/data-clone-error';
import { EncodingErrorFactory } from '../factories/encoding-error';
import { OfflineAudioBufferSourceNodeFakerFactory } from '../factories/offline-audio-buffer-source-node';
import { OfflineAudioDestinationNodeFakerFactory } from '../factories/offline-audio-destination-node';
import { OfflineBiquadFilterNodeFakerFactory } from '../factories/offline-biquad-filter-node';
import { OfflineGainNodeFakerFactory } from '../factories/offline-gain-node';
import { OfflineIIRFilterNodeFakerFactory } from '../factories/offline-iir-filter-node';
import { AudioBufferCopyChannelMethodsSupportTester } from '../testers/audio-buffer-copy-channel-methods-support';
import { PromiseSupportTester } from '../testers/promise-support';
import { AudioBufferWrapper } from '../wrappers/audio-buffer';
import { AudioBufferCopyChannelMethodsWrapper } from '../wrappers/audio-buffer-copy-channel-methods';
import { IIRFilterNodeGetFrequencyResponseMethodWrapper } from '../wrappers/iir-filter-node-get-frequency-response-method';
import { DetachedAudioBuffers } from './detached-audio-buffers';
import { unpatchedOfflineAudioContextConstructor } from './unpatched-offline-audio-context-constructor';
export var offlineAudioContextConstructor = new OpaqueToken('OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR');
export var OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
    deps: [
        AudioBufferCopyChannelMethodsSupportTester,
        AudioBufferCopyChannelMethodsWrapper,
        AudioBufferWrapper,
        DataCloneErrorFactory,
        DetachedAudioBuffers,
        EncodingErrorFactory,
        IIRFilterNodeGetFrequencyResponseMethodWrapper,
        OfflineAudioBufferSourceNodeFakerFactory,
        OfflineAudioDestinationNodeFakerFactory,
        OfflineBiquadFilterNodeFakerFactory,
        OfflineGainNodeFakerFactory,
        OfflineIIRFilterNodeFakerFactory,
        PromiseSupportTester,
        unpatchedOfflineAudioContextConstructor
    ],
    provide: offlineAudioContextConstructor,
    useFactory: function (audioBufferCopyChannelMethodsSupportTester, audioBufferCopyChannelMethodsWrapper, audioBufferWrapper, dataCloneErrorFactory, detachedAudioBuffers, encodingErrorFactory, iIRFilterNodeGetFrequencyResponseMethodWrapper, offlineAudioBufferSourceNodeFakerFactory, offlineAudioDestinationNodeFakerFactory, offlineBiquadFilterNodeFakerFactory, offlineGainNodeFakerFactory, offlineIIRFilterNodeFakerFactory, promiseSupportTester, unpatchedOfflineAudioContextConstructor) {
        var OfflineAudioContext = (function () {
            function OfflineAudioContext(numberOfChannels, length, sampleRate) {
                var fakeNodeStore = new WeakMap();
                var unpatchedOfflineAudioContext = new unpatchedOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);
                this._destination = offlineAudioDestinationNodeFakerFactory.create({ fakeNodeStore: fakeNodeStore, offlineAudioContext: this });
                this._fakeNodeStore = fakeNodeStore;
                this._isSupportingCopyChannelMethods = audioBufferCopyChannelMethodsSupportTester.test(unpatchedOfflineAudioContext);
                this._isSupportingGetFrequencyResponseErrors = false;
                this._isSupportingPromises = promiseSupportTester.test(unpatchedOfflineAudioContext);
                this._length = length;
                this._numberOfChannels = numberOfChannels;
                this._unpatchedOfflineAudioContext = unpatchedOfflineAudioContext;
            }
            Object.defineProperty(OfflineAudioContext.prototype, "currentTime", {
                get: function () {
                    return this._unpatchedOfflineAudioContext.currentTime;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(OfflineAudioContext.prototype, "destination", {
                get: function () {
                    return this._destination.proxy;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(OfflineAudioContext.prototype, "length", {
                get: function () {
                    // Bug #17: Safari does not yet expose the length.
                    if (this._unpatchedOfflineAudioContext.length === undefined) {
                        return this._length;
                    }
                    return this._unpatchedOfflineAudioContext.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(OfflineAudioContext.prototype, "onstatechange", {
                get: function () {
                    return this._unpatchedOfflineAudioContext.onstatechange;
                },
                set: function (value) {
                    this._unpatchedOfflineAudioContext.onstatechange = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(OfflineAudioContext.prototype, "sampleRate", {
                get: function () {
                    return this._unpatchedOfflineAudioContext.sampleRate;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(OfflineAudioContext.prototype, "state", {
                get: function () {
                    return this._unpatchedOfflineAudioContext.state;
                },
                enumerable: true,
                configurable: true
            });
            OfflineAudioContext.prototype.createBiquadFilter = function () {
                return offlineBiquadFilterNodeFakerFactory.create({
                    fakeNodeStore: this._fakeNodeStore,
                    nativeNode: this._unpatchedOfflineAudioContext.createBiquadFilter(),
                    offlineAudioContext: this
                }).proxy;
            };
            OfflineAudioContext.prototype.createBuffer = function (numberOfChannels, length, sampleRate) {
                // @todo Consider browsers which do not fully support this method yet.
                return this._unpatchedOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
            };
            OfflineAudioContext.prototype.createBufferSource = function () {
                return offlineAudioBufferSourceNodeFakerFactory.create({
                    fakeNodeStore: this._fakeNodeStore,
                    offlineAudioContext: this
                }).proxy;
            };
            OfflineAudioContext.prototype.createGain = function () {
                return offlineGainNodeFakerFactory.create({
                    fakeNodeStore: this._fakeNodeStore,
                    offlineAudioContext: this
                }).proxy;
            };
            OfflineAudioContext.prototype.createIIRFilter = function (feedforward, feedback) {
                var nativeNode = null;
                // Bug #9: Safari does not support IIRFilterNodes.
                if (this._unpatchedOfflineAudioContext.createIIRFilter !== undefined) {
                    nativeNode = this._unpatchedOfflineAudioContext.createIIRFilter(feedforward, feedback);
                    // Bug 23 & 24: FirefoxDeveloper does not throw NotSupportedErrors anymore.
                    if (!this._isSupportingGetFrequencyResponseErrors) {
                        iIRFilterNodeGetFrequencyResponseMethodWrapper.wrap(nativeNode);
                    }
                }
                return offlineIIRFilterNodeFakerFactory.create({
                    fakeNodeStore: this._fakeNodeStore,
                    feedback: feedback,
                    feedforward: feedforward,
                    length: this.length,
                    nativeNode: nativeNode,
                    numberOfChannels: this._numberOfChannels,
                    offlineAudioContext: this,
                    sampleRate: this._unpatchedOfflineAudioContext.sampleRate
                }).proxy;
            };
            OfflineAudioContext.prototype.decodeAudioData = function (audioData, successCallback, errorCallback) {
                var _this = this;
                if (detachedAudioBuffers.has(audioData)) {
                    var err = dataCloneErrorFactory.create();
                    if (typeof errorCallback === 'function') {
                        errorCallback(err);
                    }
                    return Promise.reject(err);
                }
                // The audioData parameter maybe of a type which can't be added to a WeakSet.
                try {
                    detachedAudioBuffers.add(audioData);
                }
                catch (err) {
                    // Ignore errors.
                }
                // Bug #21: Safari does not support promises yet.
                if (this._isSupportingPromises) {
                    // Bug #1: Chrome requires a successCallback.
                    if (successCallback === undefined) {
                        successCallback = function () { }; // tslint:disable-line:no-empty
                    }
                    return this._unpatchedOfflineAudioContext
                        .decodeAudioData(audioData, successCallback, function (err) {
                        if (typeof errorCallback === 'function') {
                            // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                            if (err instanceof DOMException && err.name === 'NotSupportedError') {
                                errorCallback(new TypeError());
                            }
                            else {
                                errorCallback(err);
                            }
                        }
                    })
                        .catch(function (err) {
                        // Bug #6: Chrome, Firefox and Opera do not call the errorCallback in case of an invalid buffer.
                        if (typeof errorCallback === 'function' && err instanceof TypeError) {
                            errorCallback(err);
                        }
                        // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                        if (err instanceof DOMException && err.name === 'NotSupportedError') {
                            throw new TypeError();
                        }
                        throw err;
                    });
                }
                // Bug #21: Safari does not return a Promise yet.
                return new Promise(function (resolve, reject) {
                    var fail = function (err) {
                        if (typeof errorCallback === 'function') {
                            errorCallback(err);
                        }
                        reject(err);
                    };
                    var succeed = function (dBffrWrppr) {
                        resolve(dBffrWrppr);
                        if (typeof successCallback === 'function') {
                            successCallback(dBffrWrppr);
                        }
                    };
                    // Bug #26: Safari throws a synchronous error.
                    try {
                        // Bug #1: Safari requires a successCallback.
                        _this._unpatchedOfflineAudioContext.decodeAudioData(audioData, function (audioBuffer) {
                            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                            if (typeof audioBuffer.copyFromChannel !== 'function') {
                                audioBufferWrapper.wrap(audioBuffer);
                                // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
                            }
                            else if (!_this._isSupportingCopyChannelMethods) {
                                audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
                            }
                            succeed(audioBuffer);
                        }, function (err) {
                            // Bug #4: Safari returns null instead of an error.
                            if (err === null) {
                                fail(encodingErrorFactory.create());
                            }
                            else {
                                fail(err);
                            }
                        });
                    }
                    catch (err) {
                        fail(err);
                    }
                });
            };
            // @todo public resume () {
            // @todo     return this._unpatchedOfflineAudioContext.resume();
            // @todo }
            OfflineAudioContext.prototype.startRendering = function () {
                var _this = this;
                return this._destination
                    .render(this._unpatchedOfflineAudioContext)
                    .then(function () {
                    // Bug #21: Safari does not support promises yet.
                    if (_this._isSupportingPromises) {
                        return _this._unpatchedOfflineAudioContext.startRendering();
                    }
                    return new Promise(function (resolve) {
                        _this._unpatchedOfflineAudioContext.oncomplete = function (event) {
                            resolve(event.renderedBuffer);
                        };
                        _this._unpatchedOfflineAudioContext.startRendering();
                    });
                });
            };
            return OfflineAudioContext;
        }());
        return OfflineAudioContext;
    }
};
//# sourceMappingURL=/users/chrisguttandin/repositories/standardized-audio-context/node_modules/tsconfig-holy-grail/src/providers/offline-audio-context-constructor.js.map