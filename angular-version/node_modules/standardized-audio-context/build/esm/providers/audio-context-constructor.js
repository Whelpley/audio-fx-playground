import { OpaqueToken } from '@angular/core';
import { DataCloneErrorFactory } from '../factories/data-clone-error';
import { EncodingErrorFactory } from '../factories/encoding-error';
import { InvalidStateErrorFactory } from '../factories/invalid-state-error';
import { IIRFilterNodeFaker } from '../fakers/iir-filter-node';
import { AnalyserNodeGetFloatTimeDomainDataSupportTester } from '../testers/analyser-node-get-float-time-domain-data';
import { AudioBufferCopyChannelMethodsSupportTester } from '../testers/audio-buffer-copy-channel-methods-support';
import { ChainingSupportTester } from '../testers/chaining-support';
import { ConnectingSupportTester } from '../testers/connecting-support';
import { DisconnectingSupportTester } from '../testers/disconnecting-support';
import { PromiseSupportTester } from '../testers/promise-support';
import { StopStoppedSupportTester } from '../testers/stop-stopped-support';
import { AnalyserNodeGetFloatTimeDomainDataMethodWrapper } from '../wrappers/analyser-node-get-float-time-domain-data-method';
import { AudioBufferWrapper } from '../wrappers/audio-buffer';
import { AudioBufferCopyChannelMethodsWrapper } from '../wrappers/audio-buffer-copy-channel-methods';
import { AudioBufferSourceNodeStopMethodWrapper } from '../wrappers/audio-buffer-source-node-stop-method';
import { AudioNodeConnectMethodWrapper } from '../wrappers/audio-node-connect-method';
import { AudioNodeDisconnectMethodWrapper } from '../wrappers/audio-node-disconnect-method';
import { ChannelMergerNodeWrapper } from '../wrappers/channel-merger-node';
import { ChannelSplitterNodeWrapper } from '../wrappers/channel-splitter-node';
import { IIRFilterNodeGetFrequencyResponseMethodWrapper } from '../wrappers/iir-filter-node-get-frequency-response-method';
import { DetachedAudioBuffers } from './detached-audio-buffers';
import { unpatchedAudioContextConstructor } from './unpatched-audio-context-constructor';
export var audioContextConstructor = new OpaqueToken('AUDIO_CONTEXT_CONSTRUCTOR');
export var AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
    deps: [
        AnalyserNodeGetFloatTimeDomainDataMethodWrapper,
        AnalyserNodeGetFloatTimeDomainDataSupportTester,
        AudioBufferCopyChannelMethodsSupportTester,
        AudioBufferCopyChannelMethodsWrapper,
        AudioBufferSourceNodeStopMethodWrapper,
        AudioBufferWrapper,
        AudioNodeConnectMethodWrapper,
        AudioNodeDisconnectMethodWrapper,
        ChainingSupportTester,
        ChannelMergerNodeWrapper,
        ChannelSplitterNodeWrapper,
        ConnectingSupportTester,
        DataCloneErrorFactory,
        DetachedAudioBuffers,
        DisconnectingSupportTester,
        EncodingErrorFactory,
        InvalidStateErrorFactory,
        IIRFilterNodeFaker,
        IIRFilterNodeGetFrequencyResponseMethodWrapper,
        PromiseSupportTester,
        StopStoppedSupportTester,
        unpatchedAudioContextConstructor
    ],
    provide: audioContextConstructor,
    useFactory: function (analyserNodeGetFloatTimeDomainDataMethodWrapper, analyserNodeGetFloatTimeDomainDataSupportTester, audioBufferCopyChannelMethodsSupportTester, audioBufferCopyChannelMethodsWrapper, audioBufferSourceNodeStopMethodWrapper, audioBufferWrapper, audioNodeConnectMethodWrapper, audioNodeDisconnectMethodWrapper, chainingSupportTester, channelMergerNodeWrapper, channelSplitterNodeWrapper, connectingSupportTester, dataCloneErrorFactory, detachedAudioBuffers, disconnectingSupportTester, encodingErrorFactory, invalidStateErrorFactory, iIRFilterNodeFaker, iIRFilterNodeGetFrequencyResponseMethodWrapper, promiseSupportTester, stopStoppedSupportTester, unpatchedAudioContextConstructor) {
        var AudioContext = (function () {
            function AudioContext() {
                var _this = this;
                var unpatchedAudioContext = new unpatchedAudioContextConstructor();
                this._isSupportingAnalyserNodeGetFloatTimeDomainData = analyserNodeGetFloatTimeDomainDataSupportTester.test(unpatchedAudioContext);
                this._isSupportingChaining = chainingSupportTester.test(unpatchedAudioContext);
                this._isSupportingCopyChannelMethods = audioBufferCopyChannelMethodsSupportTester.test(unpatchedAudioContext);
                this._isSupportingConnecting = connectingSupportTester.test(unpatchedAudioContext);
                this._isSupportingDisconnecting = false;
                // @todo Actually check for getFrequencyResponse() errors support.
                this._isSupportingGetFrequencyResponseErrors = false;
                this._isSupportingPromises = promiseSupportTester.test(unpatchedAudioContext);
                this._isSupportingStoppingOfStoppedNodes = stopStoppedSupportTester.test(unpatchedAudioContext);
                this._onStateChangeListener = null;
                this._unpatchedAudioContext = unpatchedAudioContext;
                this._state = null;
                disconnectingSupportTester
                    .test(unpatchedAudioContext)
                    .then(function (isSupportingDisconnecting) {
                    _this._isSupportingDisconnecting = isSupportingDisconnecting;
                });
                /*
                 * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually
                 * changes to 'running'.
                 */
                if (unpatchedAudioContext.state === 'running') {
                    this._state = 'suspended';
                    var revokeState_1 = function () {
                        if (_this._state === 'suspended') {
                            _this._state = null;
                        }
                        if (unpatchedAudioContext.removeEventListener) {
                            unpatchedAudioContext.removeEventListener('statechange', revokeState_1);
                        }
                    };
                    unpatchedAudioContext.addEventListener('statechange', revokeState_1);
                }
            }
            Object.defineProperty(AudioContext.prototype, "currentTime", {
                get: function () {
                    return this._unpatchedAudioContext.currentTime;
                },
                set: function (value) {
                    this._unpatchedAudioContext.currentTime = value;
                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
                    // @todo Test if this still needs to be patched.
                    throw new TypeError();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioContext.prototype, "destination", {
                get: function () {
                    return this._unpatchedAudioContext.destination;
                },
                set: function (value) {
                    this._unpatchedAudioContext.destination = value;
                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
                    // @todo Test if this still needs to be patched.
                    throw new TypeError();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioContext.prototype, "onstatechange", {
                get: function () {
                    if ('onstatechange' in this._unpatchedAudioContext) {
                        return this._unpatchedAudioContext.onstatechange;
                    }
                    return this._onStateChangeListener;
                },
                set: function (value) {
                    if ('onstatechange' in this._unpatchedAudioContext) {
                        this._unpatchedAudioContext.onstatechange = value;
                    }
                    else {
                        this._onStateChangeListener = (typeof value === 'function') ? value : null;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioContext.prototype, "sampleRate", {
                get: function () {
                    return this._unpatchedAudioContext.sampleRate;
                },
                set: function (value) {
                    this._unpatchedAudioContext.sampleRate = value;
                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
                    // @todo Test if this still needs to be patched.
                    throw new TypeError();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioContext.prototype, "state", {
                get: function () {
                    return (this._state !== null) ? this._state : this._unpatchedAudioContext.state;
                },
                set: function (value) {
                    if (this._unpatchedAudioContext.state !== undefined) {
                        this._unpatchedAudioContext.state = value;
                    }
                    /*
                     * If the unpatched AudioContext does not have a property called state or does not throw an error by itself, it has to be
                     * faked.
                     * @todo Test if this still needs to be patched.
                     */
                    throw new TypeError();
                },
                enumerable: true,
                configurable: true
            });
            AudioContext.prototype.close = function () {
                // Bug #35: Firefox does not throw an error if the AudioContext was closed before.
                if (this.state === 'closed') {
                    return this._unpatchedAudioContext
                        .close()
                        .then(function () {
                        throw invalidStateErrorFactory.create();
                    });
                }
                // Bug #34: If the state was set to suspended before it should be revoked now.
                if (this._state === 'suspended') {
                    this._state = null;
                }
                return this._unpatchedAudioContext.close();
            };
            AudioContext.prototype.createAnalyser = function () {
                if (this._unpatchedAudioContext === null) {
                    throw invalidStateErrorFactory.create();
                }
                var analyserNode = this._unpatchedAudioContext.createAnalyser();
                // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                // tslint:disable-next-line:comment-format
                // the behaviour of throwing an error.
                if (this.state === 'closed') {
                    throw invalidStateErrorFactory.create();
                }
                // Bug #37: Only Chrome Canary and Firefox create an AnalyserNode with default properties.
                if (analyserNode.channelCount === 2) {
                    analyserNode.channelCount = 1;
                }
                // Bug #36: Safari does not support getFloatTimeDomainData() yet.
                if (!this._isSupportingAnalyserNodeGetFloatTimeDomainData) {
                    analyserNodeGetFloatTimeDomainDataMethodWrapper.wrap(analyserNode);
                }
                // Bug #11: Safari does not support chaining yet.
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(analyserNode, this._isSupportingChaining);
                }
                // Only Chrome and Opera support disconnecting of a specific destination.
                if (!this._isSupportingDisconnecting) {
                    audioNodeDisconnectMethodWrapper.wrap(analyserNode);
                }
                return analyserNode;
            };
            AudioContext.prototype.createBiquadFilter = function () {
                if (this._unpatchedAudioContext === null) {
                    throw invalidStateErrorFactory.create();
                }
                var biquadFilterNode = this._unpatchedAudioContext.createBiquadFilter();
                // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                // tslint:disable-next-line:comment-format
                // the behaviour of throwing an error.
                if (this.state === 'closed') {
                    throw invalidStateErrorFactory.create();
                }
                // Bug #11: Safari does not support chaining yet.
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(biquadFilterNode, this._isSupportingChaining);
                }
                return biquadFilterNode;
            };
            AudioContext.prototype.createBuffer = function (numberOfChannels, length, sampleRate) {
                var audioBuffer = this._unpatchedAudioContext.createBuffer(numberOfChannels, length, sampleRate);
                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                if (typeof audioBuffer.copyFromChannel !== 'function') {
                    audioBufferWrapper.wrap(audioBuffer);
                    // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
                }
                else if (!this._isSupportingCopyChannelMethods) {
                    audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
                }
                return audioBuffer;
            };
            AudioContext.prototype.createBufferSource = function () {
                var audioBufferSourceNode = this._unpatchedAudioContext.createBufferSource();
                // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.
                if (!this._isSupportingStoppingOfStoppedNodes) {
                    audioBufferSourceNodeStopMethodWrapper.wrap(audioBufferSourceNode, this);
                    return audioBufferSourceNode;
                }
                // Bug #11: Safari does not support chaining yet but is already patched above.
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(audioBufferSourceNode, true);
                }
                return audioBufferSourceNode;
            };
            AudioContext.prototype.createChannelMerger = function () {
                if (this._unpatchedAudioContext === null) {
                    throw invalidStateErrorFactory.create();
                }
                var channelMergerNode = this._unpatchedAudioContext.createChannelMerger.apply(this._unpatchedAudioContext, arguments);
                // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                // tslint:disable-next-line:comment-format
                // the behaviour of throwing an error.
                if (this.state === 'closed') {
                    throw invalidStateErrorFactory.create();
                }
                // Bug #11: Safari does not support chaining yet.
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(channelMergerNode, this._isSupportingChaining);
                }
                // Bug #15: Safari does not return the default properties.
                if (channelMergerNode.channelCount !== 1 &&
                    channelMergerNode.channelCountMode !== 'explicit') {
                    channelMergerNodeWrapper.wrap(this._unpatchedAudioContext, channelMergerNode);
                }
                // Bug #16: Firefox does not throw an error when setting a different channelCount or channelCountMode.
                try {
                    channelMergerNode.channelCount = 2;
                    channelMergerNodeWrapper.wrap(this._unpatchedAudioContext, channelMergerNode);
                }
                catch (err) { } // tslint:disable-line:no-empty
                return channelMergerNode;
            };
            AudioContext.prototype.createChannelSplitter = function () {
                if (this._unpatchedAudioContext === null) {
                    throw invalidStateErrorFactory.create();
                }
                var channelSplitterNode = this._unpatchedAudioContext.createChannelSplitter.apply(this._unpatchedAudioContext, arguments);
                // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                // tslint:disable-next-line:comment-format
                // the behaviour of throwing an error.
                if (this.state === 'closed') {
                    throw invalidStateErrorFactory.create();
                }
                // Bug #11: Safari does not support chaining yet.
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(channelSplitterNode, this._isSupportingChaining);
                }
                // Bug #29 - #32: Only Chrome partially supports the spec yet.
                channelSplitterNodeWrapper.wrap(channelSplitterNode);
                return channelSplitterNode;
            };
            AudioContext.prototype.createGain = function () {
                if (this._unpatchedAudioContext === null) {
                    throw invalidStateErrorFactory.create();
                }
                var gainNode = this._unpatchedAudioContext.createGain();
                // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                // tslint:disable-next-line:comment-format
                // the behaviour of throwing an error.
                if (this.state === 'closed') {
                    throw invalidStateErrorFactory.create();
                }
                // Bug #11: Safari does not support chaining yet.
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(gainNode, this._isSupportingChaining);
                }
                // Bug #12: Firefox and Safari do not support to disconnect a specific destination.
                if (!this._isSupportingDisconnecting) {
                    audioNodeDisconnectMethodWrapper.wrap(gainNode);
                }
                return gainNode;
            };
            AudioContext.prototype.createIIRFilter = function (feedforward, feedback) {
                // Bug #10: Edge does not throw an error when the context is closed.
                if (this._unpatchedAudioContext === null && this.state === 'closed') {
                    throw invalidStateErrorFactory.create();
                }
                // Bug #9: Safari does not support IIRFilterNodes.
                if (this._unpatchedAudioContext.createIIRFilter === undefined) {
                    return iIRFilterNodeFaker.fake(feedforward, feedback, this, this._unpatchedAudioContext);
                }
                var iIRFilterNode = this._unpatchedAudioContext.createIIRFilter(feedforward, feedback);
                // Bug 23 & 24: FirefoxDeveloper does not throw NotSupportedErrors anymore.
                if (!this._isSupportingGetFrequencyResponseErrors) {
                    iIRFilterNodeGetFrequencyResponseMethodWrapper.wrap(iIRFilterNode);
                }
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(iIRFilterNode, true);
                }
                return iIRFilterNode;
            };
            AudioContext.prototype.createOscillator = function () {
                if (this._unpatchedAudioContext === null) {
                    throw invalidStateErrorFactory.create();
                }
                var oscillatorNode = this._unpatchedAudioContext.createOscillator();
                // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                // tslint:disable-next-line:comment-format
                // the behaviour of throwing an error.
                if (this.state === 'closed') {
                    throw invalidStateErrorFactory.create();
                }
                // Bug #11: Safari does not support chaining yet.
                // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                    audioNodeConnectMethodWrapper.wrap(oscillatorNode, this._isSupportingChaining);
                }
                return oscillatorNode;
            };
            AudioContext.prototype.decodeAudioData = function (audioData, successCallback, errorCallback) {
                var _this = this;
                // Bug #43: Only Chrome Canary does yet throw a DataCloneError.
                if (detachedAudioBuffers.has(audioData)) {
                    var err = dataCloneErrorFactory.create();
                    if (typeof errorCallback === 'function') {
                        errorCallback(err);
                    }
                    return Promise.reject(err);
                }
                // The audioData parameter maybe of a type which can't be added to a WeakSet.
                try {
                    detachedAudioBuffers.add(audioData);
                }
                catch (err) {
                    // Ignore errors.
                }
                // Bug #21: Safari does not support promises yet.
                if (this._isSupportingPromises) {
                    // Bug #1: Chrome requires a successCallback.
                    if (successCallback === undefined) {
                        successCallback = function () { }; // tslint:disable-line:no-empty
                    }
                    return this._unpatchedAudioContext
                        .decodeAudioData(audioData, successCallback, function (err) {
                        if (typeof errorCallback === 'function') {
                            // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                            if (err instanceof DOMException && err.name === 'NotSupportedError') {
                                errorCallback(new TypeError());
                            }
                            else {
                                errorCallback(err);
                            }
                        }
                    })
                        .catch(function (err) {
                        // Bug #6: Chrome, Firefox and Opera do not call the errorCallback in case of an invalid buffer.
                        if (typeof errorCallback === 'function' && err instanceof TypeError) {
                            errorCallback(err);
                        }
                        // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                        if (err instanceof DOMException && err.name === 'NotSupportedError') {
                            throw new TypeError();
                        }
                        throw err;
                    });
                }
                // Bug #21: Safari does not return a Promise yet.
                return new Promise(function (resolve, reject) {
                    var fail = function (err) {
                        if (typeof errorCallback === 'function') {
                            errorCallback(err);
                        }
                        reject(err);
                    };
                    var succeed = function (dBffrWrppr) {
                        resolve(dBffrWrppr);
                        if (typeof successCallback === 'function') {
                            successCallback(dBffrWrppr);
                        }
                    };
                    // Bug #26: Safari throws a synchronous error.
                    try {
                        // Bug #1: Safari requires a successCallback.
                        _this._unpatchedAudioContext.decodeAudioData(audioData, function (audioBuffer) {
                            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                            if (typeof audioBuffer.copyFromChannel !== 'function') {
                                audioBufferWrapper.wrap(audioBuffer);
                                // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
                            }
                            else if (!_this._isSupportingCopyChannelMethods) {
                                audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
                            }
                            succeed(audioBuffer);
                        }, function (err) {
                            // Bug #4: Safari returns null instead of an error.
                            if (err === null) {
                                fail(encodingErrorFactory.create());
                            }
                            else {
                                fail(err);
                            }
                        });
                    }
                    catch (err) {
                        fail(err);
                    }
                });
            };
            return AudioContext;
        }());
        return AudioContext;
    }
};
//# sourceMappingURL=/users/chrisguttandin/repositories/standardized-audio-context/node_modules/tsconfig-holy-grail/src/providers/audio-context-constructor.js.map